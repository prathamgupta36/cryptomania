#!/usr/bin/exec-suid -- /usr/bin/python3

# This file was *autogenerated* from the file /challenge/entry_gen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_10 = Integer(10); _sage_const_6 = Integer(6); _sage_const_9 = Integer(9); _sage_const_1337 = Integer(1337); _sage_const_0p01 = RealNumber('0.01'); _sage_const_0p03 = RealNumber('0.03'); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_0p5 = RealNumber('0.5'); _sage_const_1p0 = RealNumber('1.0'); _sage_const_2p0 = RealNumber('2.0'); _sage_const_5 = Integer(5)#!/usr/bin/sage 

NUM_ENTRIES   = _sage_const_100             
LOW           = _sage_const_10 **_sage_const_6          
HIGH          = _sage_const_10 **_sage_const_9          
SEED          = _sage_const_1337           
OUTPUT_PATH   = "challenge_entries"
NUDGE_FRAC_MIN = _sage_const_0p01         
NUDGE_FRAC_MAX = _sage_const_0p03        

import json, math, random, sys
from math import sqrt, pi, cos, sin, hypot
from sage.all import Matrix, ZZ

def dot(a,b): return a[_sage_const_0 ]*b[_sage_const_0 ] + a[_sage_const_1 ]*b[_sage_const_1 ]
def norm2(a): return dot(a,a)
def norm(a): return sqrt(norm2(a))

def babai_nearest(b1, b2, t):
    den1 = norm2(b1)
    if den1 == _sage_const_0 : return None
    mu21 = dot(b2, b1) / den1
    b2s  = (b2[_sage_const_0 ] - mu21*b1[_sage_const_0 ], b2[_sage_const_1 ] - mu21*b1[_sage_const_1 ])
    den2 = norm2(b2s)
    if den2 == _sage_const_0 :
        b1, b2 = b2, b1
        den1 = norm2(b1)
        if den1 == _sage_const_0 : return None
        mu21 = dot(b2, b1) / den1
        b2s  = (b2[_sage_const_0 ] - mu21*b1[_sage_const_0 ], b2[_sage_const_1 ] - mu21*b1[_sage_const_1 ])
        den2 = norm2(b2s)
        if den2 == _sage_const_0 : return None

    
    c2 = (t[_sage_const_0 ]*b2s[_sage_const_0 ] + t[_sage_const_1 ]*b2s[_sage_const_1 ]) / den2
    k2 = int(round(c2))
    t2 = (t[_sage_const_0 ] - k2*b2[_sage_const_0 ], t[_sage_const_1 ] - k2*b2[_sage_const_1 ])

    c1 = (t2[_sage_const_0 ]*b1[_sage_const_0 ] + t2[_sage_const_1 ]*b1[_sage_const_1 ]) / den1
    k1 = int(round(c1))

    px = k1*b1[_sage_const_0 ] + k2*b2[_sage_const_0 ]
    py = k1*b1[_sage_const_1 ] + k2*b2[_sage_const_1 ]
    return k1, k2, (px, py)

def refine_neighbors(b1, b2, t, k1, k2):
    best = None
    for dk1 in (-_sage_const_1 , _sage_const_0 , _sage_const_1 ):
        for dk2 in (-_sage_const_1 , _sage_const_0 , _sage_const_1 ):
            x = k1 + dk1
            y = k2 + dk2
            px = x*b1[_sage_const_0 ] + y*b2[_sage_const_0 ]
            py = x*b1[_sage_const_1 ] + y*b2[_sage_const_1 ]
            d  = hypot(t[_sage_const_0 ] - px, t[_sage_const_1 ] - py)
            if best is None or d < best[_sage_const_0 ]:
                best = (d, (px, py), (x, y))
    _, pbest, _ = best
    return pbest

def make_instance(rng):
    def rcomp():
        v = rng.randrange(LOW, HIGH+_sage_const_1 )
        return v if rng.random() < _sage_const_0p5  else -v

    B1 = (rcomp(), rcomp())
    k  = _sage_const_1p0  + _sage_const_2p0  * rng.random()
    nudge_mag = rng.randrange(LOW//_sage_const_5 , LOW)
    nudx = rng.randrange(-nudge_mag, nudge_mag+_sage_const_1 )
    nudy = rng.randrange(-nudge_mag, nudge_mag+_sage_const_1 )
    B2 = (int(k*B1[_sage_const_0 ]) + nudx, int(k*B1[_sage_const_1 ]) + nudy)

    det = B1[_sage_const_0 ]*B2[_sage_const_1 ] - B1[_sage_const_1 ]*B2[_sage_const_0 ]
    if det == _sage_const_0 :
        B2 = (B2[_sage_const_0 ] + _sage_const_1 , B2[_sage_const_1 ] - _sage_const_1 )
        det = B1[_sage_const_0 ]*B2[_sage_const_1 ] - B1[_sage_const_1 ]*B2[_sage_const_0 ]

    mid = ((B1[_sage_const_0 ] + B2[_sage_const_0 ]) / _sage_const_2p0 , (B1[_sage_const_1 ] + B2[_sage_const_1 ]) / _sage_const_2p0 )
    frac = NUDGE_FRAC_MIN + (NUDGE_FRAC_MAX - NUDGE_FRAC_MIN) * rng.random()
    step = frac * min(norm(B1), norm(B2))
    phi = _sage_const_2p0  * pi * rng.random()
    t = (mid[_sage_const_0 ] + step*cos(phi), mid[_sage_const_1 ] + step*sin(phi))

    M = Matrix(ZZ, [[int(B1[_sage_const_0 ]), int(B1[_sage_const_1 ])],
                                        [int(B2[_sage_const_0 ]), int(B2[_sage_const_1 ])]])
    M_lll = M.LLL()
    r = list(M_lll.rows())
    r1 = (float(r[_sage_const_0 ][_sage_const_0 ]), float(r[_sage_const_0 ][_sage_const_1 ]))
    r2 = (float(r[_sage_const_1 ][_sage_const_0 ]), float(r[_sage_const_1 ][_sage_const_1 ]))
    
    res = babai_nearest(r1, r2, t)
    if res is None:
        return None  
    k1, k2, (px_b, py_b) = res
    px, py = refine_neighbors(r1, r2, t, k1, k2)

    a, b = B1[_sage_const_0 ], B2[_sage_const_0 ]
    c, d = B1[_sage_const_1 ], B2[_sage_const_1 ]
    return {
        "basis_rows": [[a, b], [c, d]],
        "det": int(det),
        "target": [float(t[_sage_const_0 ]), float(t[_sage_const_1 ])],
        "nearest_point": [int(px), int(py)],
    }

rng = random.Random(SEED) if SEED is not None else random.SystemRandom()

wrote = _sage_const_0 
with open(OUTPUT_PATH, "w") as f:
    while wrote < NUM_ENTRIES:
        entry = make_instance(rng)
        if entry is None:
            continue
        f.write(json.dumps(entry, separators=(",", ":")) + "\n")
        wrote += _sage_const_1 

print(f"Wrote {wrote} entries to {OUTPUT_PATH}")
