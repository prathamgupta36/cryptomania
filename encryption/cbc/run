#!/usr/bin/exec-suid -- /usr/bin/python3

import time
import random
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.text import Text
from rich.align import Align
from rich.prompt import Prompt
import pyfiglet
import colorama

colorama.init()

class EnhancedCBCTutorial:
    def __init__(self):
        self.console = Console()
        self.colors = {
            'primary': 'bright_magenta',
            'secondary': 'bright_cyan',
            'accent': 'bright_green',
            'info': 'bright_blue',
            'warning': 'bright_yellow',
            'error': 'bright_red',
            'success': 'bright_green'
        }

    def display_banner(self):
        banner = pyfiglet.figlet_format("Cryptomania", font="slant")
        subtitle = Text("CBC Mode Encryption", style=f"bold {self.colors['info']}")
        panel = Panel(
            Align.center(Text(banner, style=f"bold {self.colors['primary']}") + Text("\n") + subtitle),
            border_style=self.colors['accent'], padding=(1,2)
        )
        self.console.print(panel)
        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"),
                      console=self.console, transient=True) as prog:
            task = prog.add_task("Initializing CBC modules...", total=100)
            for _ in range(100):
                prog.update(task, advance=1)
                time.sleep(0.005)

    def shuffle_reveal(self, flag: str):
        panel = Panel(Text("Decoding flag...", style=f"bold {self.colors['info']}"),
                      border_style=self.colors['secondary'])
        self.console.print(panel)
        time.sleep(0.75)
        revealed = ['_'] * len(flag)
        for i, ch in enumerate(flag):
            if ch in '{}_':
                revealed[i] = ch
            else:
                for _ in range(10):
                    revealed[i] = random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789')
                    self.console.print("".join(revealed), end="\r")
                    time.sleep(0.06)
                revealed[i] = ch
            self.console.print("".join(revealed), end="\r")
            time.sleep(0.06)
        self.console.print("\n")

    def demonstrate_cbc(self):
        self.console.rule(Text("CBC Mode Visualization", style=f"bold {self.colors['secondary']}"))
        time.sleep(0.5)
        plaintext_blocks = ["HELLO ", "WORLD!"]
        IV = "123456"
        previous = IV
        self.console.print(f"IV: {IV.encode().hex()} (Initialization Vector)")
        for idx, block in enumerate(plaintext_blocks, 1):
            xor_res = "".join(chr(ord(a) ^ ord(b)) for a, b in zip(block, previous))
            ct = xor_res.encode().hex()
            panel = Panel(f"[bold]Block {idx}[/bold]\n"
                          f"Plaintext: {block}\n"
                          f"XOR w/ Prev CT: {xor_res.encode().hex()}\n"
                          f"Ciphertext: {ct}",
                          title=f"Step {idx}", border_style=self.colors['accent'])
            self.console.print(panel)
            previous = xor_res
            time.sleep(0.5)
        self.console.print()

    def _enk(self, hex_block: str, key_hex: str) -> str:
        return hex(int(hex_block, 16) ^ int(key_hex, 16))[2:].zfill(len(key_hex))

    def _gen_params(self, bits=128):
        width = bits // 4
        IV = hex(random.getrandbits(bits))[2:].zfill(width)
        KEY = hex(random.getrandbits(bits))[2:].zfill(width)
        PT1 = hex(random.getrandbits(bits))[2:].zfill(width)
        PT2 = hex(random.getrandbits(bits))[2:].zfill(width)
        return IV, KEY, PT1, PT2

    def learn_flow(self):
        self.console.rule(Text("Learn: CBC Visualization", style=f"bold {self.colors['secondary']}"))
        time.sleep(0.2)
        self.demonstrate_cbc()
        self.console.print(Text("That demonstrated block chaining and XORing with the previous ciphertext/IV.\n"
                                "Use 'Tutorial' to see a full numeric example with a hidden toy cipher.\n", style=f"{self.colors['info']}"))

    def tutorial_flow(self):
        self.console.rule(Text("Tutorial: Full walkthrough (KEY shown)", style=f"bold {self.colors['secondary']}"))
        IV, KEY, PT1, PT2 = self._gen_params(bits=128)

        XOR_PT1 = hex(int(PT1,16) ^ int(IV,16))[2:].zfill(len(IV))
        CT1 = self._enk(XOR_PT1, KEY)

        XOR_PT2 = hex(int(PT2,16) ^ int(CT1,16))[2:].zfill(len(IV))
        CT2 = self._enk(XOR_PT2, KEY)

        table = Table(show_header=True, header_style=f"bold {self.colors['primary']}")
        table.add_column("Parameter", style="cyan")
        table.add_column("Value", style="green")
        table.add_row("IV", IV)
        table.add_row("Key", KEY)
        table.add_row("PT1", PT1)
        table.add_row("PT1 ⊕ IV", XOR_PT1)
        table.add_row("CT1 (E(KEY, PT1⊕IV))", CT1)
        table.add_row("PT2", PT2)
        table.add_row("PT2 ⊕ CT1", XOR_PT2)
        table.add_row("CT2 (E(KEY, PT2⊕CT1))", CT2)
        self.console.print(table)

        self.console.print(Text("\nThis is the tutorial mode: KEY is visible and you can verify the computations above.\n", style=f"{self.colors['info']}"))
        flag = "pwn.college{tutorial_flag}"
        self.shuffle_reveal(flag)

    def solve_flow(self):
        self.console.rule(Text("Solve: Compute CT2 (KEY hidden)", style=f"bold {self.colors['secondary']}"))
        IV, KEY, PT1, PT2 = self._gen_params(bits=128)

        XOR_PT1 = hex(int(PT1,16) ^ int(IV,16))[2:].zfill(len(IV))
        CT1 = self._enk(XOR_PT1, KEY)

        XOR_PT2 = hex(int(PT2,16) ^ int(CT1,16))[2:].zfill(len(IV))
        CT2 = self._enk(XOR_PT2, KEY)

        table = Table(show_header=True, header_style=f"bold {self.colors['primary']}")
        table.add_column("Parameter", style="cyan")
        table.add_column("Value", style="green")
        table.add_row("IV", IV)
        table.add_row("Key", "[hidden]")           
        table.add_row("PT1", PT1)
        table.add_row("PT1 ⊕ IV", XOR_PT1)
        table.add_row("CT1", CT1)
        table.add_row("PT2", PT2)
        table.add_row("PT2 ⊕ CT1", "[unknown]")
        table.add_row("CT2", "[unknown]")
        self.console.print(table)

        user = Prompt.ask("Compute CT2 (in hex)")
        correct = CT2
        if user.lower() == correct.lower():
            self.console.print(Text("Correct! Now you understand the toy CBC. Revealing flag...", style=f"bold {self.colors['success']}"))
            time.sleep(0.3)
            flag = self.load_flag()
            self.shuffle_reveal(flag)
        else:
            self.console.print(Text("Incorrect. Try again (no hints given).", style=f"bold {self.colors['error']}"))

    def menu(self):
        while True:
            self.console.clear()
            self.display_banner()
            choice = Prompt.ask(
                "Choose mode",
                choices=["learn", "tutorial", "solve", "exit"],
                default="learn"
            )
            if choice == "learn":
                self.learn_flow()
            elif choice == "tutorial":
                self.tutorial_flow()
            elif choice == "solve":
                self.solve_flow()
            elif choice == "exit":
                self.console.print(Text("Goodbye — stay curious!", style=f"{self.colors['info']}"))
                break

            self.console.print()
            time.sleep(1.0)
            Prompt.ask("Press Enter to return to menu", default="")

    def load_flag(self):
        try:
            return Path("/flag").read_text().strip()
        except:
            return "pwn.college{demo}"

    def run(self):
        self.console.clear()
        self.menu()


if __name__ == "__main__":
    EnhancedCBCTutorial().run()
